biobalm.petri_net_translation
=============================

.. py:module:: biobalm.petri_net_translation

.. autoapi-nested-parse::

   Utilities for translating Boolean networks into Petri nets.

   Implements the translation from a `BooleanNetwork` object into a Petri net that
   can be processed by Trappist (for finding trap spaces). The Petri net is
   represented as a `networkx.DiGraph`, with nodes having either a `kind=place` or
   a `kind=transition` attribute.

   The variable names in the network have to be "sanitized" before translation. In
   particular, this means they can't use any special characters beyond "_". In the
   resulting Petri net, we then use a "b0_*" and "b1_*" prefix to distinguish the
   "zero" and "one" places created for each variable. This is also important for
   `clingo`, as we have to guarantee that in our logic program, symbols start with
   a lowercase letter.



Attributes
----------

.. autoapisummary::

   biobalm.petri_net_translation.DEBUG


Functions
---------

.. autoapisummary::

   biobalm.petri_net_translation.sanitize_network_names
   biobalm.petri_net_translation.variable_to_place
   biobalm.petri_net_translation.place_to_variable
   biobalm.petri_net_translation.extract_variable_names
   biobalm.petri_net_translation.extract_source_variables
   biobalm.petri_net_translation.restrict_petrinet_to_subspace
   biobalm.petri_net_translation.network_to_petrinet
   biobalm.petri_net_translation.optimized_recursive_dnf_generator


Module Contents
---------------

.. py:data:: DEBUG
   :value: False


   Enables debug logging to stdout.

.. py:function:: sanitize_network_names(network: biodivine_aeon.BooleanNetwork, check_only: bool = False)

   Rename variables in a network so that they can be safely used in Trappist.

   Verifies that all network variable names contain only alphanumeric
   characters and underscores. If this is not the case, attempts to rename the
   variables to make them compliant. Returns a *copy* of the original network
   that only uses sanitized names.

   Note that AEON should already prune away most of the special characters when
   parsing models, but it still allows names like `Gene_{Subscript}` (i.e.
   curly brackets) which we have to sanitize here.

   If `check_only=True` is specified, no renaming takes place and the function
   fails with a `RuntimeError` instead.

   :param network: The network to sanitize.
   :type network: BooleanNetwork
   :param check_only: If `True`, no renaming takes place and the function fails with a
                      `RuntimeError` if the network contains invalid variable names.
   :type check_only: bool

   :returns: A copy of the original network with sanitized variable names.
   :rtype: BooleanNetwork


.. py:function:: variable_to_place(variable: str, positive: bool) -> str

   Generate a Petri net place name from a network variable name.

   :param variable: The name of the network variable.
   :type variable: str
   :param positive: `True` if the place corresponding to the variable should be positive,
                    `False` if it shoudl be negative.
   :type positive: bool

   :returns: The name of the corresponding Petri net place.
   :rtype: str


.. py:function:: place_to_variable(place: str) -> tuple[str, bool]

   Extract the variable name and state from a Petri net place name.

   :param place: The name of the Petri net place.
   :type place: str

   :returns: The name of the variable, and whether the variable is positive or negative.
   :rtype: tuple[str, bool]


.. py:function:: extract_variable_names(encoded_network: networkx.DiGraph) -> list[str]

   Extract the variable names from a Petri net encoded Boolean network.

   The variables are  sorted lexicographically, since the original BN ordering
   is not preserved by the Petri net. However, BNs order variables
   lexicographically by default, so unless the Petri net was created from a
   custom BN (i.e. not from a normal model file), the ordering should be the
   same.

   :param encoded_network: The Petri net encoded Boolean network.
   :type encoded_network: DiGraph

   :returns: The list of variable names.
   :rtype: list[str]


.. py:function:: extract_source_variables(encoded_network: networkx.DiGraph) -> list[str]

   List variable names that represent source nodes of the encoded network.

   Source nodes are those nodes with an identity update function.

   :param encoded_network: The Petri net encoded Boolean network.
   :type encoded_network: DiGraph

   :returns: The list of source variable names.
   :rtype: list[str]


.. py:function:: restrict_petrinet_to_subspace(petri_net: networkx.DiGraph, sub_space: biobalm.types.BooleanSpace) -> networkx.DiGraph

   Create a copy of a Petri net restricted to a sub-space.

   Creates a copy of the given Petri net, but with the variables given in
   `sub_space` fixed to their respective values.

   Note that this completely eliminates the constant variables from the Petri
   net, but it does not perform any further constant propagation or
   percolation. Variables that are fixed in the `sub_space` but do not exist in
   the Petri net are ignored.

   The `sub_space` can contain variables that do not appear
   in the `petri_net`. Such variables are simply ignored.

   :param petri_net: The Petri net to restrict.
   :type petri_net: DiGraph
   :param sub_space: The sub-space to restrict the Petri net to.
   :type sub_space: BooleanSpace

   :returns: The restricted Petri net.
   :rtype: DiGraph


.. py:function:: network_to_petrinet(network: biodivine_aeon.BooleanNetwork, symbolic_context: biodivine_aeon.SymbolicContext | None = None) -> networkx.DiGraph

   Convert a Boolean network to a Petri net.

   Converts a `biodivine_aeon.BooleanNetwork` to a `DiGraph` representing a Petri net encoding
   of the original network. For details about the encoding, see module
   description.

   Note that the given network needs to have "sanitized" names, otherwise the
   method will fail (see `sanitize_network_names` in this module).

   The operation uses translation through `biodivine_aeon.Bdd` to generate a
   disjunctive normal form of the network's update functions. This is
   facilitated by `biodivine_aeon.SymbolicContext`. If a suitable context already
   exists, it can be provided as the second argument. Otherwise it will be
   created.

   :param network: The network to convert.
   :type network: BooleanNetwork
   :param symbolic_context: The context used for the symbolic conversion, as an
                            `biodivine_aeon.SymbolicContext` object. This is a mapping from the
                            network nodes to BDD variables that preserves variable ordering in BDDs.
                            If not given, a new one will be created from the network.
   :type symbolic_context: SymbolicContext | None

   :returns: The Petri net encoding of the given network.
   :rtype: DiGraph


.. py:function:: optimized_recursive_dnf_generator(bdd: biodivine_aeon.Bdd) -> Generator[biodivine_aeon.BddPartialValuation, None, None]

   Yields a generator of `BddPartialValuation` objects, similar to
   `Bdd.clause_iterator` in AEON, but uses a recursive optimization strategy
   to return a smaller result than the default method `Bdd` clause sequence.
   Note that this is still not the "optimal" DNF, but is often close enough.

   This is technically slower for BDDs that already have a small clause count,
   but can be much better in the long-term when the clause count is high.


